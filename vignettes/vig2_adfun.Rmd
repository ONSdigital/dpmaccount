---
title: "Using outputs from MakeADFun"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using outputs from MakeADFun}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteTangle{true}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  fig.width = 7,
  fig.height = 7,
  comment = "#>"
)
```

# Introduction

As an experiment, we are retaining the outputs from TMB function `MakeADFun()` ("make auto-differentiation function") for subsequent analysis. To get access to these functions, run `estimate_account()` with `keep_adfun` set to `TRUE`.
```{r setup}
library(dpmaccount)
sysmod_births <- sysmod(
  mean = gl_sysmod_mean_births,
  disp = 0.2,
  nm_series = "births"
)
sysmod_deaths <- sysmod(
  mean = gl_sysmod_mean_deaths,
  disp = 0.2,
  nm_series = "deaths"
)
sysmod_ins <- sysmod(
  mean = gl_sysmod_mean_immig,
  disp = 0.2,
  nm_series = "ins"
)
sysmod_outs <- sysmod(
  mean = gl_sysmod_mean_emig,
  disp = 0.2,
  nm_series = "outs"
)
sysmods <- list(
  sysmod_births,
  sysmod_deaths,
  sysmod_ins,
  sysmod_outs
)
datamod_births <- datamod_exact(
  data = gl_report_births,
  nm_series = "births"
)
datamod_deaths <- datamod_exact(
  data = gl_report_deaths,
  nm_series = "deaths"
)
datamod_popn <- datamod_norm(
  data = gl_report_popn,
  sd = gl_cover_sd_popn,
  nm_series = "population"
)
datamod_ins <- datamod_norm(
  data = gl_report_immig,
  sd = gl_cover_sd_immig,
  nm_series = "ins"
)
datamod_outs <- datamod_norm(
  data = gl_report_emig,
  sd = gl_cover_sd_emig,
  nm_series = "outs"
)
datamods <- list(
  datamod_popn = datamod_popn,
  datamod_births = datamod_births,
  datamod_deaths = datamod_deaths,
  datamod_ins = datamod_ins,
  datamod_outs = datamod_outs
)
results <- estimate_account(
  sysmods = sysmods,
  datamods = datamods,
  keep_adfun = TRUE
) ## default is FALSE
```

The function objects can then be accessed by converting the results object into a tibble.


```{r}
results_df <- as_tibble(results)
results_df
```

This allows us to experiment with alternative optimizers,
```{r}
library(trustOptim)
f <- results_df$adfun[[5]]
x <- trust.optim(
  x = f$par,
  fn = f$fn,
  gr = f$gr,
  hs = f$hs,
  method = "SR1"
)
x
```

Or with MCMC-based methods of approximating the posterior distribution
```{r}
library(tmbstan)
y <- tmbstan(f)
y
```
