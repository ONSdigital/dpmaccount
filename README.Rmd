---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# dpmaccount

<!-- badges: start -->

[![R-CMD-check](https://github.com/ONSdigital/dpmaccount/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/ONSdigital/dpmaccount/actions/workflows/R-CMD-check.yaml)

[![Style](https://github.com/ONSdigital/dpmaccount/actions/workflows/style.yaml/badge.svg)](https://github.com/ONSdigital/dpmaccount/actions/workflows/style.yaml)

[![Contributor Covenant](https://img.shields.io/badge/Contributor%20Covenant-2.1-4baaaa.svg)](code_of_conduct.md)
<!-- badges: end -->

## Overview

The dpmaccount package provides a framework for estimating a demographic account from multiple noisy datasets using template model builder (TMB). The user specifies the 'system models' containing the underlying demographic rates and counts, and the 'data models' describing the assumed relationship between reported counts for population, births, deaths, and migration (stocks & flows), and the true underlying counts. Once the system and data models are specified, estimation is straightforward using the `estimate_account()` function, with the results held in an object of class `"dpmaccount_results"` containing all the information needed to generate estimates of counts and rates.

## Contributor guidance

**To see the complete [contributor guidance](https://github.com/ONSdigital/dpmaccount/blob/main/CONTRIBUTING.md)**

**In brief:**
All modifications to this package must be made through **Pull requests**, ideally linked to a specific GitHub **Issue**. 

Pull requests must be reviewed by someone other than the requester, if more than one individual was responsible for the requested changes the reviewer must be someone other than the main contributor, ideally it will be reviewed by someone entirely uninvolved with the particular changes made. 

Pull requests should have a suitable pull request review form attached, with key notes/descriptions of changes made added by the requester and if applicable additional notes on particular areas to focus the review (syntax changes, key functional changes, documentational changes etc.)

## Getting started

### Installation
#### Install directly from GitHub

If you have linked your RStudio installation to GitHub you should be able to install the package directly from GitHub using the install_github method from the devtools package

``` {r installation_github, eval=FALSE}
# install.packages("devtools")
library(devtools)

devtools::install_github("ONSdigital/dpmaccount", build_vignettes = TRUE, INSTALL_opts = "--no-multiarch")
```

If you have not/are unable to link your RStudio installation to GitHub (you may encounter a 404 error when attempting the previous approach) you can also install the package in two alternative ways

#### Install locally from .zip

Download a copy of the package repository as a .zip file (option in 'Code', below Open with GitHub Desktop) and install using the install_local method from the devtools package (replace the path with the path to the .zip file download location)

``` {r installation_zip, eval=FALSE}
# install.packages("devtools")
library(devtools)

devtools::install_local("C:/.../Downloads/dpmaccount-main.zip", build_vignettes = TRUE, INSTALL_opts = "--no-multiarch")
```

#### Install locally from cloned repository

Clone the repository (options in 'Code' to HTTPS/SSH paths) and build the package using the build() method from the devtools package

``` {r installation_clone, eval=FALSE}
# install.packages("devtools")
library(devtools)

dpmaccount_build <- devtools::build("~/put/the/package/path/here")

devtools::install_local(dpmaccount_build, build_vignettes = TRUE, INSTALL_opts = "--no-multiarch")
```

### Usage (example)

In this example, we illustrate the main features of **dpmaccount**, using data from Statistics Greenland. (For more on the data, see the online help for the datasets used below.) We specify and estimate a model, and then inspect the results.

First, however, we load the required packages.

```{r example_setup}
library(dpmaccount)
library(dplyr, warn.conflicts = FALSE)
library(tidyr)
library(ggplot2)
```

Next we specify the 'system models' containing the underlying demographic rates and counts, starting with 'births'
```{r example_births_sys}
sysmod_births <- sysmod(
  mean = gl_sysmod_mean_births,
  disp = 0.2,
  nm_series = "births"
)
sysmod_births
```

The models for deaths, ins, and outs are similar.
```{r example_sys}
sysmod_deaths <- sysmod(
  mean = gl_sysmod_mean_deaths,
  disp = 0.2,
  nm_series = "deaths"
)
sysmod_ins <- sysmod(
  mean = gl_sysmod_mean_immig,
  disp = 0.2,
  nm_series = "ins"
)
sysmod_outs <- sysmod(
  mean = gl_sysmod_mean_emig,
  disp = 0.2,
  nm_series = "outs"
)
```

We collect these models together into a named list
```{r example_sys_list}
sysmods <- list(
  sysmod_births,
  sysmod_deaths,
  sysmod_ins,
  sysmod_outs
)
```

Next we specify data models describing the assumed relationship between reported counts for population, births, deaths, and migration, and the true underlying counts.  

Births and deaths are a special case. We use an 'exact' data model, which tells **dpmaccount** that we are treating the births and deaths data as error-free.
```{r example_datamod_births_deaths}
datamod_births <- datamod_exact(
  data = gl_report_births,
  nm_series = "births"
)
datamod_deaths <- datamod_exact(
  data = gl_report_deaths,
  nm_series = "deaths"
)
```

For populations, ins, and outs, we use 'normal' data models
```{r datamod_pop}
datamod_popn <- datamod_norm(
  data = gl_report_popn,
  sd = gl_cover_sd_popn,
  nm_series = "population"
)
datamod_popn
```

The data models for ins and outs are similar to the one for population,
```{r datamod_ins_outs}
datamod_ins <- datamod_norm(
  data = gl_report_immig,
  sd = gl_cover_sd_immig,
  nm_series = "ins"
)
datamod_outs <- datamod_norm(
  data = gl_report_emig,
  sd = gl_cover_sd_emig,
  nm_series = "outs"
)
```

We again collect the models into a named list.
```{r datamod_list}
datamods <- list(
  datamod_popn = datamod_popn,
  datamod_births = datamod_births,
  datamod_deaths = datamod_deaths,
  datamod_ins = datamod_ins,
  datamod_outs = datamod_outs
)
```

Once the system and data models are specified, estimation is straightforward:

```{r estimate_account}
results <- estimate_account(
  sysmods = sysmods,
  datamods = datamods
)
```

The output from `estimate_account()` is held in an object of class `"dpmaccount_results"`. 

```{r results}
results
```

The outputs consist of random draws. For reproducibility, we set the random seed.
```{r set_seed}
set.seed(0)
```

Calling `summary()` on the results object produces an account with total counts and rates.

```{r summary_results}
summary(results)
```

Function `diagnostics()` provides information on the performance of the optimiser, and on any cohorts where the calculations failed.

```{r diagnostics}
diag <- diagnostics(results)
head(diag, 5)
```

The model object `results` contains all the information we need to generate estimates of counts and rates. Estimates can be obtained using the `dpmaccount_results` method for generic function `generics::components()`, however, for many purposes, the three `augment` functions

- `augment_population()`
- `augment_events()`
- `augment_rates()`

are more convenient. All three functions are variants on the generic function `generics::augment()`, which is part of the [tidymodels](https://www.tidymodels.org) framework. Augment functions contain the original dataset, augmented by columns with various types of estimate. 

`augment_population()`, for instance, gives the original population data, combined with posterior draws for population counts (`population`), posterior means (`population.fitted`) and lower and upper limits for a 95% credible interval (`population.lower` and `population.upper`).

```{r augment_pop}
res_population <- results %>%
  augment_population()
head(res_population, 5)
```

Having the raw data and the results together in the same data frame makes it easy to construct plots that compare data and results.

```{r results_population_plot}
ggplot(
  res_population,
  aes(
    x = age,
    ymin = population.lower,
    y = population.fitted,
    ymax = population.upper
  )
) +
  facet_grid(vars(sex), vars(time)) +
  geom_pointrange(
    fatten = 0.2,
    col = "darkorange"
  ) +
  geom_point(aes(y = gl_report_popn),
    col = "darkblue",
    size = 0.3
  ) +
  ylab("")
```

`components()`, `augment_population()`, `augment_events()`, and `augment_rates()` all have a `collapse` argument that can be used to collapse away age, sex, or cohort dimensions. To obtain population data and estimates classified only by sex and time, for instance, we use
```{r augment_population_collapse}
results %>%
  augment_population(collapse = c("age", "cohort"))
```

Function `augment_events()` gives the original events (flows) data, combined with posterior draws for immigration counts (`ins`), posterior means (`ins.fitted`) and lower and upper limits for a 95% credible interval (`ins.lower` and `ins.upper`), as well as the posterior draws for emigration counts (`outs`), posterior means (`outs.fitted`) and lower and upper limits for a 95% credible interval (`outs.lower` and `outs.upper`)

```{r augment_events}
res_events <- results %>%
  augment_events()
head(res_events, 5)
```

Similarly to the population counts, it easy to construct plots that compare data and results for the events, starting with immigration (ins).

```{r results_events_ins_plot}
ggplot(
  res_events,
  aes(
    x = age,
    ymin = ins.lower,
    y = ins.fitted,
    ymax = ins.upper
  )
) +
  facet_grid(vars(sex), vars(time)) +
  geom_pointrange(
    fatten = 0.2,
    col = "darkorange"
  ) +
  geom_point(aes(y = gl_report_immig),
    col = "darkblue",
    size = 0.3
  ) +
  ylab("")
```
 
Also the emigration (outs)

```{r results_events_outs_plot}
ggplot(
  res_events,
  aes(
    x = age,
    ymin = outs.lower,
    y = outs.fitted,
    ymax = outs.upper
  )
) +
  facet_grid(vars(sex), vars(time)) +
  geom_pointrange(
    fatten = 0.2,
    col = "darkorange"
  ) +
  geom_point(aes(y = gl_report_emig),
    col = "darkblue",
    size = 0.3
  ) +
  ylab("")
```

Function `augment_rates()` returns a particularly rich set of results:

- variables starting with `direct` are 'direct estimates' of rates, that is, estimates formed by dividing observed event counts by observed exposures
- variables starting with `prior` describe prior distributions for rates, obtained by drawing from system models
- variables starting with `post` describe posterior distributions for rates, obtained via TMB

```{r augment_rates_collapse}
res_rates <- results %>%
  augment_rates(collapse = c("cohort", "sex"))
```

To illustrate some of the possibilities, we show emigration rates for 2022,


```{r results_rates_outs_2022}
rates_emig <- res_rates %>%
  filter(time == 2022) %>%
  select(age, time,
    direct = direct.gl_report_emig,
    starts_with("prior.outs"),
    starts_with("post.outs")
  ) %>%
  select(!where(is.list)) %>%
  pivot_longer(
    cols = c(starts_with("prior"), starts_with("post")),
    names_to = c("series", "level"),
    names_pattern = "(.*)\\.outs\\.(.*)"
  ) %>%
  pivot_wider(names_from = level)
head(rates_emig, 5)
```

```{r results_rates_outs_plot, fig.width = 7, fig.height = 5}
ggplot(rates_emig, aes(x = age)) +
  geom_pointrange(
    aes(
      ymin = lower,
      y = fitted,
      ymax = upper,
      color = series
    ),
    fatten = 0.2
  ) +
  scale_color_manual(values = c(
    prior = "lightblue",
    post = "darkblue"
  )) +
  geom_point(aes(y = direct),
    col = "red",
    size = 0.3
  ) +
  ylab("") +
  theme(legend.position = "top")
```

And also immigration counts.


```{r results_rates_ins_2022}
rates_immig <- res_rates %>%
  filter(time == 2022) %>%
  select(age, time,
    direct = direct.gl_report_immig,
    starts_with("prior.ins"),
    starts_with("post.ins")
  ) %>%
  select(!where(is.list)) %>%
  pivot_longer(
    cols = c(starts_with("prior"), starts_with("post")),
    names_to = c("series", "level"),
    names_pattern = "(.*)\\.ins\\.(.*)"
  ) %>%
  pivot_wider(names_from = level)
head(rates_immig, 5)
```


```{r results_rates_ins_plot, fig.width = 7, fig.height = 5}
ggplot(rates_immig, aes(x = age)) +
  geom_pointrange(
    aes(
      ymin = lower,
      y = fitted,
      ymax = upper,
      color = series
    ),
    fatten = 0.2
  ) +
  scale_color_manual(values = c(
    prior = "lightblue",
    post = "darkblue"
  )) +
  geom_point(aes(y = direct),
    col = "red",
    size = 0.3
  ) +
  ylab("") +
  theme(legend.position = "top")
```


## FAQs/Help

1. There are missing values in the results of augmenting the population/events (augment_population(), augment_events(), augment_rates()) 
   - This typically occurs where cohorts have failed
   - The usual causes are inconsistencies in the input data
   - These failures can be mitigated through the use of the optional *scale_sd* and *scale_ratio* inputs to the data model functions (default - datamod_norm(..., scale_sd = 0, scale_ratio = 0))
   - The optional input to change depends on where the suspected consistencies are e.g. the stocks uncertainty (scale_sd - only available in datamod_norm()) or the coverage ratios (scale_ratio)
   - Setting these to be > 0 can aid cohort failures (e.g. a value of 0.05 is approximately equivalent to a 5% scaling).

  
  2. The account produced appears not to be consistent.
  
  e.g. population_time_1 < population_time_0 + births + in_migration - deaths - out_migration
  
  - There are typically two causes; rounding error in printed results, and/or extinct cohorts related to system model definitions.
   - `summary(results)` rounds estimated values to the nearest integer and this occasionally leads to apparent inconsistencies. Instead, running `results |> augment_population()` and `results |> augment_events()` will give better precision in estimates.
   - The data you provide for the system models defines the age range that estimates are created for. If the maximum age in your system model data is 105, while there could be people in the population aged greater than 105, `dpmaccount` will not produce estimates for ages greater than 105. Cohorts will only ever be estimated up to this maximum age.

## License
By contributing, you agree that your contributions will be licensed under its [MIT License](http://choosealicense.com/licenses/mit/). For additional information regarding the licensing, and related copyright, of this code please refer to the [LICENSE](https://github.com/ONSdigital/dpmaccount/blob/main/LICENSE.md)

